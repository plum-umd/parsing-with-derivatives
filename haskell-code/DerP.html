<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Derp</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Derp.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption" class="empty">&nbsp;</p></div><div id="content"><div id="module-header"><p class="caption">Derp</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#1">Data Types
</a></li><li><a href="#2">Parser construction
</a></li><li><a href="#3">Parser computation steps
</a></li><li><a href="#4">Full parsing and result extraction
</a></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Parser">Parser</a> a</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Token">Token</a>  = <a href="#v:Token">Token</a> {<ul class="subs"><li><a href="#v:tokenClass">tokenClass</a> :: String</li><li><a href="#v:tokenValue">tokenValue</a> :: String</li></ul>}</li><li class="src short"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:-60--126--62-">(&lt;~&gt;)</a> :: (ResultType a, ResultType b) =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> b -&gt; <a href="Derp.html#t:Parser">Parser</a> (a, b)</li><li class="src short"><a href="#v:-61--61--62-">(==&gt;)</a> :: (ResultType a, ResultType b) =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; (a -&gt; b) -&gt; <a href="Derp.html#t:Parser">Parser</a> b</li><li class="src short"><a href="#v:-61--61--62--124-">(==&gt;|)</a> :: (ResultType a, ResultType b) =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; (Set a -&gt; Set b) -&gt; <a href="Derp.html#t:Parser">Parser</a> b</li><li class="src short"><a href="#v:nul">nul</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:pzip">pzip</a> :: (ResultType a, ResultType b) =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; Context a b -&gt; <a href="Derp.html#t:Parser">Parser</a> b</li><li class="src short"><a href="#v:ter">ter</a> :: String -&gt; <a href="Derp.html#t:Parser">Parser</a> String</li><li class="src short"><a href="#v:eps">eps</a> :: ResultType a =&gt; a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:epsM">epsM</a> :: ResultType a =&gt; Set a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:emp">emp</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:derive">derive</a> ::  <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Token">Token</a> -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:compact">compact</a> ::  <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:parseNull">parseNull</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; Set a</li><li class="src short"><a href="#v:defaultCompactSteps">defaultCompactSteps</a> :: Int</li><li class="src short"><a href="#v:compactNum">compactNum</a> ::  Int -&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:deriveStepNum">deriveStepNum</a> ::  Int -&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Token">Token</a> -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:runParseNum">runParseNum</a> :: ResultType a =&gt; Int -&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; [<a href="Derp.html#t:Token">Token</a>] -&gt; Set a</li><li class="src short"><a href="#v:deriveStep">deriveStep</a> ::  <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Token">Token</a> -&gt; <a href="Derp.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:runParse">runParse</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; [<a href="Derp.html#t:Token">Token</a>] -&gt; Set a</li></ul></div><div id="interface"><h1 id="1">Data Types
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Parser" class="def">Parser</a> a </p><div class="doc"><p>Represents both a formal context-free language and the
   reduction of a member of that language to a value of type <code>a</code>.
</p></div><div class="subs instances"><p id="control.i:Parser" class="caption collapser" onclick="toggleSection('i:Parser')">Instances</p><div id="section.i:Parser" class="show"><table><tr><td class="src">Show (<a href="Derp.html#t:Parser">Parser</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Token" class="def">Token</a>  </p><div class="doc"><p>The input type for parsing.  For example the parser:
</p><pre> (ter &quot;x&quot;) 
</pre><p>will parse:
</p><pre> (Token &quot;x&quot; &quot;foo&quot;) 
</pre><p>into:
</p><pre> (eps &quot;foo&quot;)
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Token" class="def">Token</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:tokenClass" class="def">tokenClass</a> :: String</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:tokenValue" class="def">tokenValue</a> :: String</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Token" class="caption collapser" onclick="toggleSection('i:Token')">Instances</p><div id="section.i:Token" class="show"><table><tr><td class="src">Eq <a href="Derp.html#t:Token">Token</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Ord <a href="Derp.html#t:Token">Token</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Show <a href="Derp.html#t:Token">Token</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="2">Parser construction
</h1><div class="top"><p class="src"><a name="v:-60--124--62-" class="def">(&lt;|&gt;)</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>Alternation.
</p></div></div><div class="top"><p class="src"><a name="v:-60--126--62-" class="def">(&lt;~&gt;)</a> :: (ResultType a, ResultType b) =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> b -&gt; <a href="Derp.html#t:Parser">Parser</a> (a, b)</p><div class="doc"><p>Concatenation.
</p></div></div><div class="top"><p class="src"><a name="v:-61--61--62-" class="def">(==&gt;)</a> :: (ResultType a, ResultType b) =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; (a -&gt; b) -&gt; <a href="Derp.html#t:Parser">Parser</a> b</p><div class="doc"><p>Reduction.
</p></div></div><div class="top"><p class="src"><a name="v:-61--61--62--124-" class="def">(==&gt;|)</a> :: (ResultType a, ResultType b) =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; (Set a -&gt; Set b) -&gt; <a href="Derp.html#t:Parser">Parser</a> b</p><div class="doc"><p>Set generalized version of <code><a href="Derp.html#v:-61--61--62-">==&gt;</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:nul" class="def">nul</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>Null-parse extraction.
</p></div></div><div class="top"><p class="src"><a name="v:pzip" class="def">pzip</a> :: (ResultType a, ResultType b) =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; Context a b -&gt; <a href="Derp.html#t:Parser">Parser</a> b</p><div class="doc"><p>One-hole-context focus.
</p></div></div><div class="top"><p class="src"><a name="v:ter" class="def">ter</a> :: String -&gt; <a href="Derp.html#t:Parser">Parser</a> String</p><div class="doc"><p>Terminal.
</p></div></div><div class="top"><p class="src"><a name="v:eps" class="def">eps</a> :: ResultType a =&gt; a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>Epsilon/empty-string.
</p></div></div><div class="top"><p class="src"><a name="v:epsM" class="def">epsM</a> :: ResultType a =&gt; Set a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>Set generalized version of <code><a href="Derp.html#v:eps">eps</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:emp" class="def">emp</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>The empty language.
</p></div></div><h1 id="3">Parser computation steps
</h1><div class="top"><p class="src"><a name="v:derive" class="def">derive</a> ::  <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Token">Token</a> -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>The main derivative function.
</p></div></div><div class="top"><p class="src"><a name="v:compact" class="def">compact</a> ::  <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>The optimization step of the algorithm.
</p></div></div><div class="top"><p class="src"><a name="v:parseNull" class="def">parseNull</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; Set a</p><div class="doc"><p>Extract the parse-null set of a parser.
</p></div></div><h1 id="4">Full parsing and result extraction
</h1><div class="top"><p class="src"><a name="v:defaultCompactSteps" class="def">defaultCompactSteps</a> :: Int</p><div class="doc"><p>The number of compact steps that usually keeps a parser constant in size
   while parsing.
</p></div></div><div class="top"><p class="src"><a name="v:compactNum" class="def">compactNum</a> ::  Int -&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>A specified number of compactions.
</p></div></div><div class="top"><p class="src"><a name="v:deriveStepNum" class="def">deriveStepNum</a> ::  Int -&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Token">Token</a> -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>Derivation followed by specified number of compactions.
</p></div></div><div class="top"><p class="src"><a name="v:runParseNum" class="def">runParseNum</a> :: ResultType a =&gt; Int -&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; [<a href="Derp.html#t:Token">Token</a>] -&gt; Set a</p><div class="doc"><p>Parse using a specified number of intermediate compactions.
</p></div></div><div class="top"><p class="src"><a name="v:deriveStep" class="def">deriveStep</a> ::  <a href="Derp.html#t:Parser">Parser</a> a -&gt; <a href="Derp.html#t:Token">Token</a> -&gt; <a href="Derp.html#t:Parser">Parser</a> a</p><div class="doc"><p>Derivation followed by the default number of compactions.
</p></div></div><div class="top"><p class="src"><a name="v:runParse" class="def">runParse</a> :: ResultType a =&gt; <a href="Derp.html#t:Parser">Parser</a> a -&gt; [<a href="Derp.html#t:Token">Token</a>] -&gt; Set a</p><div class="doc"><p>Parse using the default number of intermediate compactions.  This is the
   main parsing function.  Examples:
</p><pre> let e =     ter &quot;num&quot;
         &lt;|&gt; e &lt;~&gt; ter &quot;+&quot; &lt;~&gt; e ==&gt; (\(x1,(o,x2)) -&gt; &quot;(&quot; ++ x1 ++ o ++ x2 ++ &quot;)&quot;)
 in runParse e [Token &quot;num&quot; &quot;1&quot;, Token &quot;+&quot; &quot;+&quot;, Token &quot;num&quot; 3&quot;, Token &quot;+&quot; &quot;+&quot;, Token &quot;num&quot; &quot;5&quot;]
</pre><p>evaluates to:
</p><pre> Set.fromList [&quot;((1+3)+5)&quot;, &quot;(1+(3+5))&quot;]
</pre><pre> let e =     ter &quot;num&quot; ==&gt; read 
         &lt;|&gt; e &lt;~&gt; ter &quot;+&quot; &lt;~&gt; e ==&gt; (\(x1,(_,x2)) -&gt; x1 + x2)
 in runParse e [Token &quot;num&quot; &quot;1&quot;, Token &quot;+&quot; &quot;+&quot;, Token &quot;num&quot; 3&quot;, Token &quot;+&quot; &quot;+&quot;, Token &quot;num&quot; &quot;5&quot;]
</pre><p>evaluates to:
</p><pre> Set.fromList [9]
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.8.0</p></div></body></html>